from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any

from pydantic import BaseModel, Field, HttpUrl

# --- Enums ---
class ArtifactType(str, Enum):
    """The type of the artifact being registered."""
    model = "model"
    dataset = "dataset"
    code = "code"

# --- Core Schemas (Matching OpenAPI Spec) ---
class ArtifactData(BaseModel):
    """Source location for ingesting an artifact."""
    url: HttpUrl = Field(..., description="Artifact source url used during ingest.")
    name: Optional[str] = None
    download_url: Optional[HttpUrl] = Field(None, description="Direct download link served by your server")

class ArtifactReturnURL(BaseModel):
    url: HttpUrl = Field(..., description="Artifact source url used during ingest.")

class ArtifactMetadata(BaseModel):
    """Metadata for an artifact."""
    name: str = Field(..., description="Name of the artifact")
    id: str = Field(..., description="Unique identifier for the artifact")
    type: ArtifactType = Field(..., description="Type of artifact")

class Artifact(BaseModel):
    """Complete artifact envelope."""
    metadata: ArtifactMetadata
    data: ArtifactData

class ArtifactReturn(BaseModel):
    """Complete artifact return envelope."""
    metadata: ArtifactMetadata
    data: ArtifactReturnURL

class ArtifactQuery(BaseModel):
    """Query structure for searching artifacts."""
    name: str = Field(..., description="Name to search for. Use '*' for all artifacts.")
    types: Optional[List[ArtifactType]] = Field(None, description="Optional filter by artifact types")

# --- Model Rating Schema ---
class SizeScore(BaseModel):
    """Size scores for different deployment targets."""
    raspberry_pi: float
    jetson_nano: float
    desktop_pc: float
    aws_server: float

class ModelRating(BaseModel):
    """Model rating summary generated by evaluation service."""
    name: str
    category: str
    net_score: float
    net_score_latency: float
    ramp_up_time: float
    ramp_up_time_latency: float
    bus_factor: float
    bus_factor_latency: float
    performance_claims: float
    performance_claims_latency: float
    license: float
    license_latency: float
    dataset_and_code_score: float
    dataset_and_code_score_latency: float
    dataset_quality: float
    dataset_quality_latency: float
    code_quality: float
    code_quality_latency: float
    size_score: SizeScore
    size_score_latency: float
    # new fields for phase 2
    reproducibility: float  # 0, 0.5, or 1
    reproducibility_latency: float
    reviewedness: float  # Fraction of code from reviewed PRs, or -1
    reviewedness_latency: float
    tree_score: float  # Average score of parent models
    tree_score_latency: float

# --- Additional Phase 2 Requirements ---
class ArtifactCost(BaseModel):
    standalone_cost: Optional[float] = None
    total_cost: float

class EnumerateOffset(str):
    """Pagination offset."""
    pass


class LineageNode(BaseModel):
    artifact_id: int
    name: str
    source: str


class LineageEdge(BaseModel):
    from_node_artifact_id: int
    to_node_artifact_id: int
    relationship: str


class ArtifactLineageGraph(BaseModel):
    nodes: List[LineageNode]
    edges: List[LineageEdge]


class SimpleLicenseCheckRequest(BaseModel):
    """Request body for a simple license check."""
    github_url: HttpUrl = Field(..., description="GitHub URL of the project to check")


class ArtifactRegEx(BaseModel):
    """Request schema for searching artifacts by regex."""
    regex: str = Field(..., description="Regular expression to search artifact names or metadata")
